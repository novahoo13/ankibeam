# Anki 单词助手 - 动态字段功能技术说明书

**文档版本：** v1.0  
**创建日期：** 2025年9月3日  
**适用版本：** feature/stage-1-architecture 及后续版本  
**技术负责人：** [待分配]  

---

## 1. 项目现状分析

### 1.1 当前代码架构概述

项目采用典型的Chrome扩展架构，主要包含以下模块：

```
├── popup/                # 主界面
│   ├── popup.html       # 用户交互界面
│   ├── popup.js         # 主要逻辑处理
│   └── popup.css        # 界面样式
├── options/             # 配置页面
│   ├── options.html     # 配置界面
│   ├── options.js       # 配置逻辑
│   └── options.css      # 配置样式
└── utils/               # 核心工具模块
    ├── ai-service.js    # AI服务接口
    ├── ankiconnect.js   # AnkiConnect API
    ├── storage.js       # 配置存储管理
    └── i18n.js          # 国际化支持
```

### 1.2 当前实现机制分析

#### 1.2.1 UI 界面限制
**位置：** `popup/popup.html:25-34`
```html
<div class="result-section">
  <div class="form-group">
    <label for="front-input">正面:</label>
    <input type="text" id="front-input" />
  </div>
  <div class="form-group">
    <label for="back-input">背面:</label>
    <textarea id="back-input" rows="8"></textarea>
  </div>
</div>
```
**问题：** 界面固定只有两个输入框，无法适配不同模板的字段数量。

#### 1.2.2 数据处理限制
**位置：** `popup/popup.js:54-55, 107-109`
```javascript
// AI解析结果固定格式
document.getElementById('front-input').value = result.front || '';
document.getElementById('back-input').value = result.back || '';

// 写入时固定使用前两个字段
fields[fieldNames[0]] = frontHtml; // 第一个字段作为正面
fields[fieldNames[1]] = backHtml;  // 第二个字段作为背面
```
**问题：** 数据处理逻辑硬编码为两个字段，无法利用模板的其他字段。

#### 1.2.3 AI 解析输出限制
**位置：** `utils/ai-service.js:84-96`
```javascript
const defaultPromptTemplate = `
请将以下单词查询结果解析为结构化数据。
你的输出必须是一个纯粹的JSON对象，不要包含任何解释性文字或代码块标记。
JSON格式如下:
{
  "front": "单词",
  "back": "完整的单词查询结果（保留原始换行格式）"
}
```
**问题：** AI 输出格式固定为 `{front, back}` 结构，无法适配多字段需求。

### 1.3 现有优势和可扩展基础

#### 1.3.1 AnkiConnect 集成完善
- **字段获取功能：** `getModelFieldNames()` 已能动态获取任意模板字段
- **模板切换支持：** options.js 已实现模板选择和字段信息显示
- **连接测试机制：** 完整的连接状态检测和错误处理

#### 1.3.2 配置系统架构良好
- **分层配置结构：** aiConfig, ankiConfig, styleConfig 等模块化配置
- **加密存储：** API Key 等敏感信息的安全存储机制
- **实时保存：** 配置变更的即时保存和加载

#### 1.3.3 模块化设计清晰
- **服务分离：** AI 服务、Anki 服务、存储服务独立封装
- **错误处理：** 统一的错误处理和用户反馈机制
- **代码结构：** 清晰的文件组织和函数职责划分

---

## 2. 修改背景说明

### 2.1 业务需求驱动

#### 2.1.1 用户痛点
1. **模板适配性差：** 不同用户使用不同的 Anki 模板，字段数量和名称各异
2. **信息利用率低：** AI 解析出的丰富信息只能填入两个字段，造成数据浪费
3. **扩展性受限：** 无法满足语言学习的多样化需求（发音、例句、词源等）

#### 2.1.2 具体使用场景
- **基础模板：** 只需要"单词"和"释义"两个字段
- **标准模板：** 需要"单词"、"释义"、"例句"、"发音"四个字段  
- **高级模板：** 包含"单词"、"释义"、"例句"、"发音"、"词源"、"相关词汇"等多个字段
- **自定义模板：** 用户根据学习需要创建的特殊字段组合

### 2.2 技术发展必要性

#### 2.2.1 当前限制的技术债务
- **维护成本高：** 每次支持新字段都需要修改多处代码
- **用户体验差：** 无法充分利用 AI 解析能力和 Anki 模板功能
- **竞争力不足：** 功能固化限制了产品的差异化优势

#### 2.2.2 架构升级收益
- **灵活性提升：** 支持任意 Anki 模板，满足不同用户需求
- **智能化增强：** AI 可以针对不同字段提供更精准的内容解析
- **可扩展性强：** 为后续功能（批量处理、模板推荐等）奠定基础

---

## 3. 技术方案设计

### 3.1 整体架构设计

#### 3.1.1 系统架构图
```
┌─────────────────┐    ┌──────────────────┐    ┌─────────────────┐
│   用户界面层     │    │    业务逻辑层     │    │   数据存储层     │
├─────────────────┤    ├──────────────────┤    ├─────────────────┤
│ 动态表单生成器   │ ←→ │  字段映射管理器   │ ←→ │  配置存储系统    │
│ 模板选择器      │    │  AI解析协调器    │    │  字段缓存系统    │
│ 字段映射配置器   │    │  数据验证器      │    │  模板信息缓存    │
└─────────────────┘    └──────────────────┘    └─────────────────┘
                              ↕
┌─────────────────────────────────────────────────────────────────┐
│                        外部服务层                                │
├─────────────────────────────────────────────────────────────────┤
│         AI 服务 (Gemini)           │      AnkiConnect 服务       │
└─────────────────────────────────────────────────────────────────┘
```

#### 3.1.2 数据流设计
```
用户输入文本 → AI解析(动态字段) → 字段映射转换 → UI动态渲染 → 用户确认 → Anki写入
     ↑                ↓                ↓              ↑            ↓
配置管理器 ←← 模板字段获取 → 字段映射配置 ← 用户交互 → 数据验证 → 错误处理
```

### 3.2 核心组件设计

#### 3.2.1 字段映射管理器 (FieldMappingManager)
**职责：** 管理 AI 字段与 Anki 字段之间的映射关系

```javascript
class FieldMappingManager {
  constructor() {
    this.mappings = new Map(); // 模板名称 -> 字段映射
    this.cache = new Map();    // 字段信息缓存
  }
  
  // 获取模板的字段映射配置
  async getMappingForModel(modelName) { ... }
  
  // 设置字段映射关系
  async setMapping(modelName, mapping) { ... }
  
  // 根据映射转换数据
  transformData(aiResult, mapping) { ... }
  
  // 验证字段映射的有效性
  validateMapping(modelName, mapping) { ... }
}
```

#### 3.2.2 动态表单生成器 (DynamicFormGenerator)
**职责：** 根据模板字段动态生成用户界面

```javascript
class DynamicFormGenerator {
  // 根据字段信息生成表单HTML
  generateForm(fields, values = {}) { ... }
  
  // 绑定表单事件监听器
  bindFormEvents(formContainer) { ... }
  
  // 从表单获取用户输入数据
  getFormData(formContainer) { ... }
  
  // 验证表单数据完整性
  validateFormData(data, requiredFields) { ... }
}
```

#### 3.2.3 AI解析协调器 (AIParseCoordinator) 
**职责：** 协调 AI 解析和字段映射的整个流程

```javascript
class AIParseCoordinator {
  constructor(fieldMappingManager, aiService) { ... }
  
  // 根据模板生成动态Prompt
  buildDynamicPrompt(inputText, fieldMapping) { ... }
  
  // 执行AI解析并进行字段映射
  async parseAndMap(inputText, modelName) { ... }
  
  // 处理解析结果的后处理
  postProcessResult(result, mapping) { ... }
}
```

### 3.3 配置数据结构扩展

#### 3.3.1 新增配置结构
```javascript
// 扩展后的配置对象结构
const configSchema = {
  // 现有配置保持不变
  aiConfig: { ... },
  ankiConfig: {
    defaultDeck: "...",
    defaultModel: "...",
    defaultTags: [...],
    
    // 新增：字段映射配置
    fieldMappings: {
      "Basic": {                           // 模板名称
        "Front": "word",                   // Anki字段 -> AI字段
        "Back": "definition"
      },
      "Basic (and reversed card)": {
        "Front": "word",
        "Back": "definition"
      },
      "语言学习卡片": {
        "单词": "word",
        "释义": "definition", 
        "例句": "example",
        "发音": "pronunciation",
        "词源": "etymology"
      }
    },
    
    // 新增：字段显示配置
    fieldDisplayConfig: {
      "语言学习卡片": {
        "单词": { required: true, placeholder: "请输入单词" },
        "释义": { required: true, placeholder: "请输入释义" },
        "例句": { required: false, placeholder: "请输入例句" },
        "发音": { required: false, placeholder: "请输入发音" },
        "词源": { required: false, placeholder: "请输入词源" }
      }
    }
  },
  
  // 新增：动态解析配置
  dynamicParseConfig: {
    enableFieldDetection: true,           // 启用字段自动检测
    fieldDetectionPrompts: {              // 字段检测提示词
      "word": ["单词", "词汇", "term"],
      "definition": ["释义", "定义", "含义"],
      "example": ["例句", "示例"],
      "pronunciation": ["发音", "读音"],
      "etymology": ["词源", "来源"]
    }
  }
}
```

---

## 4. 具体实现步骤

### 4.1 阶段一：配置系统扩展 (预估3-4天)

#### 4.1.1 扩展配置数据结构
**文件：** `utils/storage.js`
```javascript
// 在现有配置加载函数中添加默认字段映射
export async function loadConfig() {
  // 现有代码保持不变
  const config = result[CONFIG_KEY];
  
  // 新增：为配置添加默认字段映射
  if (config && !config.ankiConfig?.fieldMappings) {
    config.ankiConfig = config.ankiConfig || {};
    config.ankiConfig.fieldMappings = getDefaultFieldMappings();
  }
  
  return config;
}

// 新增：默认字段映射配置
function getDefaultFieldMappings() {
  return {
    "Basic": {
      "Front": "word",
      "Back": "definition"
    },
    "Basic (and reversed card)": {
      "Front": "word", 
      "Back": "definition"
    }
  };
}
```

#### 4.1.2 创建字段映射管理器
**文件：** `utils/field-mapping.js` (新建)
```javascript
// 字段映射管理器实现
export class FieldMappingManager {
  constructor() {
    this.cache = new Map();
  }
  
  async getMappingForModel(modelName) {
    const config = await loadConfig();
    const mappings = config?.ankiConfig?.fieldMappings || {};
    return mappings[modelName] || this.generateDefaultMapping(modelName);
  }
  
  async setMapping(modelName, mapping) {
    const config = await loadConfig();
    config.ankiConfig = config.ankiConfig || {};
    config.ankiConfig.fieldMappings = config.ankiConfig.fieldMappings || {};
    config.ankiConfig.fieldMappings[modelName] = mapping;
    await saveConfig(config);
  }
  
  transformData(aiResult, mapping) {
    const transformed = {};
    for (const [ankiField, aiField] of Object.entries(mapping)) {
      transformed[ankiField] = aiResult[aiField] || '';
    }
    return transformed;
  }
  
  // 为新模板生成默认映射
  generateDefaultMapping(modelName) {
    // 获取模板字段，生成智能默认映射
    return getModelFieldNames(modelName).then(result => {
      const fields = result.result || [];
      const mapping = {};
      
      // 智能映射逻辑
      if (fields.length >= 1) mapping[fields[0]] = 'word';
      if (fields.length >= 2) mapping[fields[1]] = 'definition';
      if (fields.length >= 3) mapping[fields[2]] = 'example';
      if (fields.length >= 4) mapping[fields[3]] = 'pronunciation';
      
      return mapping;
    });
  }
}
```

#### 4.1.3 扩展 AnkiConnect 缓存机制
**文件：** `utils/ankiconnect.js`
```javascript
// 新增字段信息缓存
const fieldCache = new Map();

export async function getModelFieldNames(modelName) {
  // 检查缓存
  if (fieldCache.has(modelName)) {
    return { result: fieldCache.get(modelName), error: null };
  }
  
  try {
    const response = await invoke('modelFieldNames', { modelName: modelName });
    // 缓存结果
    fieldCache.set(modelName, response.result);
    return { result: response.result, error: null };
  } catch (e) {
    return { result: null, error: e.message };
  }
}

// 新增：清除缓存函数
export function clearFieldCache() {
  fieldCache.clear();
}
```

### 4.2 阶段二：AI 解析系统改造 (预估2-3天)

#### 4.2.1 创建动态 Prompt 生成器
**文件：** `utils/prompt-builder.js` (新建)
```javascript
export class DynamicPromptBuilder {
  constructor() {
    this.baseTemplate = `
请将以下文本内容解析为结构化的JSON数据。
根据提供的字段要求，尽可能准确地提取和组织信息。

输出格式要求：
- 必须是纯粹的JSON对象，不包含任何解释文字
- 如果某个字段无法从文本中提取，则设为空字符串
- 保持原始文本的换行和格式

字段要求：
{{FIELD_REQUIREMENTS}}

待解析的文本：
---
{{INPUT_TEXT}}
---
`;
  }
  
  buildPrompt(inputText, fieldMapping) {
    // 根据字段映射构建字段要求描述
    const fieldRequirements = this.buildFieldRequirements(fieldMapping);
    
    return this.baseTemplate
      .replace('{{FIELD_REQUIREMENTS}}', fieldRequirements)
      .replace('{{INPUT_TEXT}}', inputText);
  }
  
  buildFieldRequirements(fieldMapping) {
    const requirements = [];
    for (const [ankiField, aiField] of Object.entries(fieldMapping)) {
      const description = this.getFieldDescription(aiField);
      requirements.push(`"${aiField}": ${description}`);
    }
    
    return requirements.join('\n');
  }
  
  getFieldDescription(fieldType) {
    const descriptions = {
      'word': '要学习的单词或词汇',
      'definition': '单词的释义、定义或含义解释',
      'example': '使用该单词的例句或示例',
      'pronunciation': '单词的发音信息（音标、罗马音等）',
      'etymology': '单词的词源、来源或构词信息',
      'related': '相关词汇、同义词或反义词',
      'category': '单词的分类或词性信息'
    };
    
    return descriptions[fieldType] || '相关信息内容';
  }
}
```

#### 4.2.2 改造 AI 服务接口
**文件：** `utils/ai-service.js`
```javascript
import { DynamicPromptBuilder } from './prompt-builder.js';

// 修改现有解析函数
export async function parseText(inputText, fieldMapping, customPrompt) {
  const config = await loadConfig();
  const geminiConfig = config?.aiConfig?.models?.gemini;
  const apiKey = geminiConfig?.apiKey;
  const modelName = geminiConfig?.modelName || 'gemini-1.5-flash';

  if (!apiKey) {
    throw new Error('未配置 Gemini API Key');
  }

  // 使用动态Prompt构建器
  const promptBuilder = new DynamicPromptBuilder();
  const fullPrompt = customPrompt || promptBuilder.buildPrompt(inputText, fieldMapping);

  // 其余代码保持不变...
  const response = await fetch(apiEndpoint, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'x-goog-api-key': apiKey
    },
    body: JSON.stringify({
      contents: [{
        parts: [{ "text": fullPrompt }]
      }],
      generationConfig: {
        "response_mime_type": "application/json",
      }
    })
  });

  // ... 处理响应的代码保持不变
  
  const data = await response.json();
  const jsonText = data.candidates[0].content.parts[0].text;
  return JSON.parse(jsonText);
}

// 新增：AI解析协调器
export class AIParseCoordinator {
  constructor() {
    this.fieldMappingManager = new FieldMappingManager();
    this.promptBuilder = new DynamicPromptBuilder();
  }
  
  async parseAndMap(inputText, modelName, customPrompt) {
    // 获取字段映射
    const fieldMapping = await this.fieldMappingManager.getMappingForModel(modelName);
    
    // 执行AI解析
    const aiResult = await parseText(inputText, fieldMapping, customPrompt);
    
    // 转换数据格式
    const mappedResult = this.fieldMappingManager.transformData(aiResult, fieldMapping);
    
    return {
      original: aiResult,
      mapped: mappedResult,
      fieldMapping: fieldMapping
    };
  }
}
```

### 4.3 阶段三：UI 动态渲染系统 (预估4-5天)

#### 4.3.1 创建动态表单生成器
**文件：** `utils/form-generator.js` (新建)
```javascript
export class DynamicFormGenerator {
  constructor() {
    this.formContainer = null;
    this.eventListeners = [];
  }
  
  generateForm(fields, values = {}, fieldConfig = {}) {
    const formHTML = [];
    
    fields.forEach(field => {
      const config = fieldConfig[field] || {};
      const value = values[field] || '';
      const required = config.required ? 'required' : '';
      const placeholder = config.placeholder || `请输入${field}`;
      
      // 根据字段内容长度决定使用 input 还是 textarea
      const isLongContent = value.length > 50 || field.includes('释义') || field.includes('例句');
      const inputType = isLongContent ? 'textarea' : 'input';
      
      if (inputType === 'textarea') {
        formHTML.push(`
          <div class="form-group">
            <label for="field-${field}" data-field="${field}">${field}:</label>
            <textarea id="field-${field}" 
                     name="${field}" 
                     rows="4" 
                     placeholder="${placeholder}"
                     ${required}>${value}</textarea>
          </div>
        `);
      } else {
        formHTML.push(`
          <div class="form-group">
            <label for="field-${field}" data-field="${field}">${field}:</label>
            <input type="text" 
                   id="field-${field}" 
                   name="${field}" 
                   value="${value}" 
                   placeholder="${placeholder}"
                   ${required} />
          </div>
        `);
      }
    });
    
    return formHTML.join('');
  }
  
  renderForm(containerId, fields, values, fieldConfig) {
    const container = document.getElementById(containerId);
    if (!container) {
      throw new Error(`Container ${containerId} not found`);
    }
    
    // 清除现有表单和事件监听器
    this.clearForm();
    
    // 生成新表单
    const formHTML = this.generateForm(fields, values, fieldConfig);
    container.innerHTML = formHTML;
    
    // 绑定事件监听器
    this.bindFormEvents(container);
    
    this.formContainer = container;
  }
  
  bindFormEvents(container) {
    // 添加输入验证
    const inputs = container.querySelectorAll('input, textarea');
    inputs.forEach(input => {
      const listener = this.createInputValidator(input);
      input.addEventListener('blur', listener);
      this.eventListeners.push({ element: input, event: 'blur', listener });
    });
  }
  
  createInputValidator(input) {
    return function(event) {
      const value = event.target.value.trim();
      const isRequired = event.target.hasAttribute('required');
      
      if (isRequired && !value) {
        event.target.classList.add('error');
        // 可以添加错误提示
      } else {
        event.target.classList.remove('error');
      }
    };
  }
  
  getFormData() {
    if (!this.formContainer) return {};
    
    const data = {};
    const inputs = this.formContainer.querySelectorAll('input, textarea');
    
    inputs.forEach(input => {
      data[input.name] = input.value;
    });
    
    return data;
  }
  
  clearForm() {
    // 清除事件监听器
    this.eventListeners.forEach(({ element, event, listener }) => {
      element.removeEventListener(event, listener);
    });
    this.eventListeners = [];
    
    if (this.formContainer) {
      this.formContainer.innerHTML = '';
    }
  }
}
```

#### 4.3.2 改造主界面逻辑
**文件：** `popup/popup.js`
```javascript
import { parseText } from '../utils/ai-service.js';
import { addNote, getModelFieldNames } from '../utils/ankiconnect.js';
import { loadConfig } from '../utils/storage.js';
import { FieldMappingManager } from '../utils/field-mapping.js';
import { DynamicFormGenerator } from '../utils/form-generator.js';
import { AIParseCoordinator } from '../utils/ai-service.js';

// 模块级变量
let config = {};
let formGenerator = null;
let aiCoordinator = null;
let currentModelFields = [];

document.addEventListener('DOMContentLoaded', () => {
  initialize();
});

async function initialize() {
  config = await loadConfig() || {};
  formGenerator = new DynamicFormGenerator();
  aiCoordinator = new AIParseCoordinator();
  
  console.log('配置已加载:', config);

  // 绑定事件监听
  document.getElementById('parse-btn').addEventListener('click', handleParse);
  document.getElementById('write-btn').addEventListener('click', handleWriteToAnki);
  
  // 初始化界面 - 根据配置的默认模板加载字段
  await initializeForm();
}

async function initializeForm() {
  const defaultModel = config?.ankiConfig?.defaultModel;
  if (defaultModel) {
    await updateFormForModel(defaultModel);
  } else {
    // 如果没有配置默认模板，显示基础表单
    await updateFormForModel('Basic');
  }
}

async function updateFormForModel(modelName) {
  try {
    const fieldsResult = await getModelFieldNames(modelName);
    if (fieldsResult.error) {
      console.warn(`无法获取模板字段，使用默认配置: ${fieldsResult.error}`);
      currentModelFields = ['Front', 'Back']; // 默认字段
    } else {
      currentModelFields = fieldsResult.result;
    }
    
    // 渲染动态表单
    const fieldConfig = config?.ankiConfig?.fieldDisplayConfig?.[modelName] || {};
    formGenerator.renderForm('result-section', currentModelFields, {}, fieldConfig);
    
  } catch (error) {
    console.error('更新表单失败:', error);
    // 降级到基础表单
    currentModelFields = ['Front', 'Back'];
    formGenerator.renderForm('result-section', currentModelFields, {}, {});
  }
}

async function handleParse() {
  const textInput = document.getElementById('text-input').value;
  if (!textInput.trim()) {
    updateStatus('请输入内容后再解析', 'error');
    return;
  }

  setUiLoading(true, '解析中...');

  try {
    const modelName = config?.ankiConfig?.defaultModel || 'Basic';
    const customPrompt = config?.promptTemplates?.custom;
    
    // 使用AI解析协调器进行解析
    const parseResult = await aiCoordinator.parseAndMap(textInput, modelName, customPrompt);
    
    // 更新表单显示
    const fieldConfig = config?.ankiConfig?.fieldDisplayConfig?.[modelName] || {};
    formGenerator.renderForm('result-section', currentModelFields, parseResult.mapped, fieldConfig);

    document.getElementById('write-btn').disabled = false;
    updateStatus('解析成功，请确认后写入。', 'success');
  } catch (error) {
    console.error('解析失败:', error);
    updateStatus(`解析失败: ${error.message}`, 'error');
  } finally {
    setUiLoading(false);
  }
}

async function handleWriteToAnki() {
  // 从动态表单获取数据
  const formData = formGenerator.getFormData();
  
  // 验证必填字段
  const requiredFields = currentModelFields.slice(0, 2); // 至少前两个字段必填
  const missingFields = requiredFields.filter(field => !formData[field]?.trim());
  
  if (missingFields.length > 0) {
    updateStatus(`请填写必填字段: ${missingFields.join(', ')}`, 'error');
    return;
  }

  setUiLoading(true, '正在写入 Anki...');
  document.getElementById('write-btn').disabled = true;

  try {
    const deckName = config?.ankiConfig?.defaultDeck || '系统默认';
    const modelName = config?.ankiConfig?.defaultModel || 'Basic';
    const tags = config?.ankiConfig?.defaultTags || [];

    // 处理字段数据并应用样式
    const fields = {};
    for (const [fieldName, value] of Object.entries(formData)) {
      fields[fieldName] = wrapContentWithStyle(value);
    }
    
    const noteData = {
      deckName: deckName,
      modelName: modelName,
      fields: fields,
      tags: tags
    };
    
    const result = await addNote(noteData);
    if (result.error) {
      throw new Error(result.error);
    }
    
    updateStatus(`成功创建卡片 (ID: ${result.result})`, 'success');
  } catch (error) {
    console.error('写入 Anki 失败:', error);
    updateStatus(`写入失败: ${error.message}`, 'error');
  } finally {
    setUiLoading(false);
    document.getElementById('write-btn').disabled = false;
  }
}

// 其余辅助函数保持不变...
function setUiLoading(isLoading, message = '') {
  document.getElementById('parse-btn').disabled = isLoading;
  document.getElementById('write-btn').disabled = isLoading;
  updateStatus(message, 'loading');
}

function wrapContentWithStyle(content) {
  const styleConfig = config?.styleConfig || {};
  const fontSize = styleConfig.fontSize || '14px';
  const textAlign = styleConfig.textAlign || 'left';
  const lineHeight = styleConfig.lineHeight || '1.4';
  
  const contentWithBreaks = content.replace(/\n/g, '<br>');
  return `<div style="font-size: ${fontSize}; text-align: ${textAlign}; line-height: ${lineHeight};">${contentWithBreaks}</div>`;
}

function updateStatus(message, type = '') {
  const statusElement = document.getElementById('status-message');
  statusElement.textContent = message;
  statusElement.className = `status-${type}`;
}
```

#### 4.3.3 更新主界面 HTML
**文件：** `popup/popup.html`
```html
<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <title>Anki 单词助手</title>
  <link rel="stylesheet" href="popup.css">
</head>
<body>
  <div class="container">
    <header>
      <h1 data-i18n="appName">Anki 单词助手</h1>
      <div id="status-indicator"></div>
    </header>

    <main>
      <div class="input-section">
        <textarea id="text-input" rows="10" placeholder="在此处粘贴单词查询结果..."></textarea>
      </div>

      <div class="action-section">
        <button id="parse-btn" data-i18n="parseBtn">解析</button>
        <button id="write-btn" data-i18n="writeBtn" disabled>写入 Anki</button>
      </div>

      <!-- 修改：使用动态生成的表单容器 -->
      <div id="result-section" class="result-section">
        <!-- 动态生成的表单将插入这里 -->
      </div>
    </main>

    <footer>
      <p id="status-message"></p>
    </footer>
  </div>
  <script type="module" src="popup.js"></script>
</body>
</html>
```

### 4.4 阶段四：配置界面增强 (预估2-3天)

#### 4.4.1 增强字段映射配置界面
**文件：** `options/options.html`
```html
<!-- 在现有的 anki-config section 中添加 -->
<section id="anki-config">
  <!-- ... 现有内容保持不变 ... -->
  
  <!-- 增强：字段映射配置 -->
  <div id="field-mapping" class="form-group" style="display: none;">
    <h3>字段映射配置</h3>
    <div class="field-mapping-container">
      <div class="mapping-header">
        <span>Anki 字段</span>
        <span>映射到 AI 字段</span>
        <span>操作</span>
      </div>
      <div id="mapping-rows">
        <!-- 动态生成的映射行将插入这里 -->
      </div>
      <button id="add-mapping-btn" type="button">添加映射</button>
    </div>
    
    <!-- 预设映射选择 -->
    <div class="preset-mappings">
      <h4>预设映射模板</h4>
      <select id="mapping-presets">
        <option value="">选择预设模板</option>
        <option value="basic">基础模板 (单词-释义)</option>
        <option value="standard">标准模板 (单词-释义-例句)</option>
        <option value="advanced">高级模板 (单词-释义-例句-发音-词源)</option>
      </select>
      <button id="apply-preset-btn" type="button">应用预设</button>
    </div>
  </div>
</section>
```

#### 4.4.2 增强配置页面逻辑
**文件：** `options/options.js`
```javascript
import { FieldMappingManager } from '../utils/field-mapping.js';

// 添加新的模块变量
let fieldMappingManager = null;
let currentModelName = '';
let currentModelFields = [];

// 在现有初始化函数中添加
document.addEventListener('DOMContentLoaded', () => {
  fieldMappingManager = new FieldMappingManager();
  
  // 现有事件监听保持不变...
  
  // 新增事件监听器
  document.getElementById('add-mapping-btn').addEventListener('click', handleAddMapping);
  document.getElementById('apply-preset-btn').addEventListener('click', handleApplyPreset);
  document.getElementById('mapping-presets').addEventListener('change', handlePresetChange);
});

// 修改现有的 handleModelChange 函数
async function handleModelChange() {
  const modelName = document.getElementById('default-model').value;
  currentModelName = modelName;
  
  if (!modelName) {
    document.getElementById('field-mapping').style.display = 'none';
    return;
  }
  
  try {
    const fieldsResult = await getModelFieldNames(modelName);
    if (fieldsResult.error) {
      throw new Error(fieldsResult.error);
    }
    
    currentModelFields = fieldsResult.result;
    
    // 显示字段映射区域
    const fieldMappingDiv = document.getElementById('field-mapping');
    fieldMappingDiv.style.display = 'block';
    
    // 加载现有映射配置
    await loadFieldMappingUI(modelName, currentModelFields);
    
  } catch (error) {
    console.error('获取字段信息失败:', error);
    document.getElementById('field-mapping').style.display = 'none';
  }
}

async function loadFieldMappingUI(modelName, fields) {
  // 获取现有映射配置
  const mapping = await fieldMappingManager.getMappingForModel(modelName);
  
  // 生成映射行
  const mappingRows = document.getElementById('mapping-rows');
  mappingRows.innerHTML = '';
  
  fields.forEach(field => {
    const aiField = mapping[field] || '';
    const row = createMappingRow(field, aiField);
    mappingRows.appendChild(row);
  });
}

function createMappingRow(ankiField, aiField) {
  const row = document.createElement('div');
  row.className = 'mapping-row';
  row.innerHTML = `
    <div class="mapping-cell">
      <input type="text" value="${ankiField}" readonly class="anki-field" />
    </div>
    <div class="mapping-cell">
      <select class="ai-field-select">
        <option value="">选择AI字段</option>
        <option value="word" ${aiField === 'word' ? 'selected' : ''}>单词 (word)</option>
        <option value="definition" ${aiField === 'definition' ? 'selected' : ''}>释义 (definition)</option>
        <option value="example" ${aiField === 'example' ? 'selected' : ''}>例句 (example)</option>
        <option value="pronunciation" ${aiField === 'pronunciation' ? 'selected' : ''}>发音 (pronunciation)</option>
        <option value="etymology" ${aiField === 'etymology' ? 'selected' : ''}>词源 (etymology)</option>
        <option value="related" ${aiField === 'related' ? 'selected' : ''}>相关词汇 (related)</option>
      </select>
    </div>
    <div class="mapping-cell">
      <button type="button" class="remove-mapping-btn" onclick="removeMapping(this)">移除</button>
    </div>
  `;
  
  // 添加变更监听器
  const select = row.querySelector('.ai-field-select');
  select.addEventListener('change', handleMappingChange);
  
  return row;
}

async function handleMappingChange() {
  if (!currentModelName) return;
  
  // 收集当前映射配置
  const mapping = {};
  const rows = document.querySelectorAll('#mapping-rows .mapping-row');
  
  rows.forEach(row => {
    const ankiField = row.querySelector('.anki-field').value;
    const aiField = row.querySelector('.ai-field-select').value;
    if (aiField) {
      mapping[ankiField] = aiField;
    }
  });
  
  // 保存映射配置
  await fieldMappingManager.setMapping(currentModelName, mapping);
}

function handleApplyPreset() {
  const presetType = document.getElementById('mapping-presets').value;
  if (!presetType || !currentModelFields.length) return;
  
  const presets = {
    basic: {
      [currentModelFields[0]]: 'word',
      [currentModelFields[1]]: 'definition'
    },
    standard: {
      [currentModelFields[0]]: 'word',
      [currentModelFields[1]]: 'definition',
      [currentModelFields[2]]: 'example'
    },
    advanced: {
      [currentModelFields[0]]: 'word',
      [currentModelFields[1]]: 'definition',
      [currentModelFields[2]]: 'example',
      [currentModelFields[3]]: 'pronunciation',
      [currentModelFields[4]]: 'etymology'
    }
  };
  
  const preset = presets[presetType];
  if (preset) {
    applyMappingPreset(preset);
  }
}

function applyMappingPreset(preset) {
  const rows = document.querySelectorAll('#mapping-rows .mapping-row');
  rows.forEach(row => {
    const ankiField = row.querySelector('.anki-field').value;
    const select = row.querySelector('.ai-field-select');
    if (preset[ankiField]) {
      select.value = preset[ankiField];
    }
  });
  
  // 触发保存
  handleMappingChange();
}

// 修改现有的保存函数，包含字段映射
async function handleSave() {
  // ... 现有代码保持不变 ...
  
  // 保存当前的字段映射（如果有的话）
  if (currentModelName) {
    await handleMappingChange();
  }
  
  // ... 其余保存逻辑保持不变 ...
}
```

---

## 5. 测试验证方案

### 5.1 功能测试清单

#### 5.1.1 基础功能测试
- [ ] 加载现有配置时保持向后兼容
- [ ] 动态表单根据模板正确生成
- [ ] AI 解析结果正确映射到表单字段
- [ ] 字段映射配置能正确保存和加载
- [ ] 不同模板间切换时数据处理正确

#### 5.1.2 边界情况测试
- [ ] 模板字段数量为0时的处理
- [ ] 模板字段数量超过10个时的界面表现
- [ ] AI 解析返回不完整数据时的容错处理
- [ ] 网络异常时的错误提示和恢复
- [ ] 字段映射冲突时的处理逻辑

#### 5.1.3 兼容性测试
- [ ] 现有配置数据的迁移和兼容
- [ ] 不同 Anki 版本的AnkiConnect兼容性
- [ ] 各种浏览器环境下的表现一致性
- [ ] 中文字符和特殊字符的正确处理

### 5.2 性能测试指标

#### 5.2.1 响应时间要求
- 动态表单生成：< 100ms
- 字段映射配置加载：< 200ms
- AI 解析和映射处理：< 5s
- 配置保存操作：< 500ms

#### 5.2.2 内存使用监控
- 扩展内存占用增长 < 20%
- 字段缓存大小控制在合理范围
- 长时间使用无内存泄漏

### 5.3 用户体验测试

#### 5.3.1 易用性评估
- [ ] 字段映射配置界面直观易懂
- [ ] 预设模板能覆盖常见使用场景
- [ ] 错误提示信息清晰有用
- [ ] 操作流程符合用户习惯

#### 5.3.2 学习成本评估
- [ ] 新用户能在5分钟内完成基础配置
- [ ] 配置选项有合理的默认值
- [ ] 高级功能不影响基础用户使用

---

## 6. 风险评估和应对策略

### 6.1 技术风险

#### 6.1.1 兼容性风险
**风险：** 新版本可能与现有配置不兼容
**应对：** 
- 实施配置版本管理和迁移机制
- 提供配置重置和恢复功能
- 充分的向后兼容性测试

#### 6.1.2 性能风险
**风险：** 动态生成可能影响界面响应速度
**应对：**
- 实施字段信息缓存机制
- 使用虚拟滚动优化长列表显示
- 分批加载和渲染大量字段

#### 6.1.3 数据一致性风险
**风险：** 字段映射配置与实际模板不匹配
**应对：**
- 实施映射验证和自动修复机制
- 提供映射状态检查工具
- 友好的错误提示和手动修正选项

### 6.2 用户体验风险

#### 6.2.1 学习成本风险
**风险：** 新功能增加了使用复杂度
**应对：**
- 提供详细的使用说明和示例
- 设计合理的默认配置
- 实现渐进式功能开放

#### 6.2.2 迁移成本风险
**风险：** 现有用户需要重新配置
**应对：**
- 提供一键迁移工具
- 保持原有功能的使用方式
- 提供配置导入导出功能

---

## 7. 部署和发布计划

### 7.1 发布策略

#### 7.1.1 内部测试版本 (Alpha)
- **目标：** 核心功能验证
- **范围：** 开发团队内部测试
- **重点：** 基础功能完整性和稳定性

#### 7.1.2 封闭测试版本 (Beta)
- **目标：** 用户体验优化
- **范围：** 有限用户群体测试
- **重点：** 易用性和兼容性验证

#### 7.1.3 正式发布版本 (Release)
- **目标：** 全面上线推广
- **范围：** 所有用户可用
- **重点：** 稳定性和性能表现

### 7.2 回滚预案

#### 7.2.1 配置回滚机制
- 保留上一版本配置的备份
- 提供配置版本切换功能
- 实现自动配置修复工具

#### 7.2.2 功能降级预案
- 支持动态禁用新功能
- 提供传统模式切换选项
- 确保核心功能不受影响

---

## 8. 后续迭代规划

### 8.1 短期优化 (1-2个月)

#### 8.1.1 用户体验增强
- 添加拖拽排序功能
- 实现字段预览和即时反馈
- 优化移动设备适配

#### 8.1.2 智能化提升
- 实现字段内容自动推荐
- 添加模板使用统计和推荐
- 优化AI解析准确度

### 8.2 中期扩展 (3-6个月)

#### 8.2.1 高级功能
- 支持批量处理和导入
- 添加字段间的关联和计算
- 实现模板市场和分享机制

#### 8.2.2 集成扩展
- 支持更多AI服务提供商
- 集成在线词典和语料库
- 添加同步和备份功能

### 8.3 长期规划 (6个月以上)

#### 8.3.1 平台扩展
- 开发移动端版本
- 支持其他学习平台集成
- 实现云端配置同步

#### 8.3.2 生态建设
- 建立开发者API
- 支持插件和扩展机制
- 构建用户社区和支持体系

---

## 9. 总结

### 9.1 技术收益
1. **灵活性大幅提升：** 支持任意Anki模板，适应不同学习需求
2. **智能化程度增强：** AI解析更精准，充分利用模板字段
3. **用户体验改善：** 界面动态适配，配置更加直观
4. **系统可扩展性强：** 为后续功能迭代奠定良好基础

### 9.2 实施建议
1. **分阶段实施：** 按照本文档规划分4个阶段逐步实现
2. **充分测试：** 重点关注兼容性和用户体验测试
3. **用户反馈：** 在Beta阶段收集用户意见并及时调整
4. **文档完善：** 提供详细的用户使用指南和开发文档

### 9.3 成功指标
- 功能完整度 ≥ 95%
- 向后兼容性 = 100%
- 用户满意度 ≥ 90%
- 系统稳定性 ≥ 99.5%

通过实施本技术方案，项目将显著提升产品的灵活性和用户体验，为Anki单词助手的长期发展奠定坚实的技术基础。

---

**文档维护：** 请在实施过程中及时更新本文档，记录实际遇到的问题和解决方案，为后续迭代提供参考。