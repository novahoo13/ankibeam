// popup.js - 主界面逻辑
// 负责处理用户交互、调用服务并更新UI

import { parseText } from '../utils/ai-service.js';
import { addNote, getModelFieldNames } from '../utils/ankiconnect.js';
import { loadConfig } from '../utils/storage.js';
// import { i18n } from '../utils/i18n.js'; // 待实现

// 模块级变量，用于存储加载的配置
let config = {};

// 用于管理状态消息自动清除的定时器
let statusTimer = null;

document.addEventListener('DOMContentLoaded', () => {
  // 初始化：加载配置、绑定事件监听器
  initialize();
});

/**
 * 初始化函数
 */
async function initialize() {
  // 加载配置并存储到模块级变量中，如果没配置则使用空对象
  config = await loadConfig() || {};
  console.log('配置已加载:', config);

  // 绑定事件监听
  document.getElementById('parse-btn').addEventListener('click', handleParse);
  document.getElementById('write-btn').addEventListener('click', handleWriteToAnki);

  // TODO: 根据配置和状态初始化UI
  // TODO: 实现国际化加载
}

/**
 * 处理解析按钮点击事件
 */
async function handleParse() {
  const textInput = document.getElementById('text-input').value;
  if (!textInput.trim()) {
    updateStatus('请输入内容后再解析', 'error');
    return;
  }

  // 更新UI为“解析中”状态
  setUiLoading(true, '解析中...');

  try {
    // 优先使用自定义prompt。如果不存在，则传递 undefined，
    // ai-service 中的 buildPrompt 函数将自动使用其内部的默认模板。
    const customPrompt = config?.promptTemplates?.custom;
    
    const result = await parseText(textInput, customPrompt);

    // 更新结果预览区域
    document.getElementById('front-input').value = result.front || '';
    document.getElementById('back-input').value = result.back || '';

    // 更新UI为“解析完成”状态
    document.getElementById('write-btn').disabled = false;
    updateStatus('解析成功，请确认后写入。', 'success');
  } catch (error) {
    console.error('解析失败:', error);
    updateStatus(`解析失败: ${error.message}`, 'error');
  } finally {
    // 恢复UI
    setUiLoading(false);
  }
}

/**
 * 处理写入Anki按钮点击事件
 */
async function handleWriteToAnki() {
  const front = document.getElementById('front-input').value;
  const back = document.getElementById('back-input').value;

  if (!front || !back) {
    updateStatus('卡片正面和背面不能为空', 'error');
    return;
  }

  // 更新UI为“写入中”状态
  setUiLoading(true, '正在写入 Anki...');
  document.getElementById('write-btn').disabled = true;

  try {
    // 从配置中获取牌组、模型等信息，并提供默认值
    const deckName = config?.ankiConfig?.defaultDeck || '系统默认';
    const modelName = config?.ankiConfig?.defaultModel || '问答题';
    const tags = config?.ankiConfig?.defaultTags || [];

    // 处理换行格式并应用样式：将普通换行转换为HTML换行标签，并包装样式
    const frontHtml = wrapContentWithStyle(front);
    const backHtml = wrapContentWithStyle(back);
    
    // 从配置中获取字段列表，不再进行API调用
    const fieldNames = config?.ankiConfig?.modelFields;
    if (!fieldNames || fieldNames.length < 2) {
      throw new Error("模板配置不完整，请前往设置页面，重新选择并保存模板。");
    }
    
    // 使用模板的前两个字段
    const fields = {};
    fields[fieldNames[0]] = frontHtml; // 第一个字段作为正面
    fields[fieldNames[1]] = backHtml;  // 第二个字段作为背面
    
    const noteData = {
      deckName: deckName,
      modelName: modelName,
      fields: fields,
      tags: tags
    };
    
    const result = await addNote(noteData);
    if (result.error) {
      throw new Error(result.error);
    }
    updateStatus(`成功创建卡片 (ID: ${result.result})`, 'success');
  } catch (error) {
    console.error('写入 Anki 失败:', error);
    updateStatus(`写入失败: ${error.message}`, 'error');
  } finally {
    setUiLoading(false);
    document.getElementById('write-btn').disabled = false;
  }
}

/**
 * 更新UI加载状态
 * @param {boolean} isLoading 是否正在加载
 * @param {string} [message=''] 加载时显示的消息
 */
function setUiLoading(isLoading, message = '') {
  document.getElementById('parse-btn').disabled = isLoading;
  document.getElementById('write-btn').disabled = isLoading;
  // TODO: 实现更明显的加载指示器，例如一个spinner
  updateStatus(message, 'loading');
}

/**
 * 将文本内容包装为带样式的 HTML
 * @param {string} content - 原始文本内容
 * @returns {string} - 包装后的 HTML 内容
 */
function wrapContentWithStyle(content) {
  // 从配置中获取样式设置，提供默认值
  const styleConfig = config?.styleConfig || {};
  const fontSize = styleConfig.fontSize || '14px';
  const textAlign = styleConfig.textAlign || 'left';
  const lineHeight = styleConfig.lineHeight || '1.4';
  
  // 处理换行符
  const contentWithBreaks = content.replace(/\n/g, '<br>');
  
  // 包装为带内联样式的 div
  return `<div style="font-size: ${fontSize}; text-align: ${textAlign}; line-height: ${lineHeight};">${contentWithBreaks}</div>`;
}

/**
 * 更新状态消息
 * @param {string} message - 要显示的消息
 * @param {'success'|'error'|'loading'|''} type - 消息类型
 */
function updateStatus(message, type = '') {
  const statusElement = document.getElementById('status-message');
  statusElement.textContent = message;
  statusElement.className = `status-${type}`;
  
  // 清除之前的定时器
  if (statusTimer) {
    clearTimeout(statusTimer);
    statusTimer = null;
  }
  
  // 为成功和错误消息设置2秒后自动清除
  if (type === 'success' || type === 'error') {
    statusTimer = setTimeout(() => {
      statusElement.textContent = '';
      statusElement.className = '';
      statusTimer = null;
    }, 2000);
  }
}

